<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Correlation Analysis Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        /* Header */
        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 1.5rem 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            position: sticky;
            top: 0;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.8rem;
            background: linear-gradient(45deg, #00d4ff, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-weight: 700;
        }

        .stats {
            display: flex;
            gap: 2rem;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: 600;
            color: #00d4ff;
        }

        .stat-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
        }

        /* Navigation Tabs */
        .nav-tabs {
            background: #1a1a2e;
            padding: 0 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            position: sticky;
            top: 80px;
            z-index: 999;
        }

        .nav-tabs-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 0.5rem;
        }

        .tab {
            padding: 1rem 2rem;
            background: transparent;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 8px 8px 0 0;
        }

        .tab:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .tab.active {
            color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00d4ff, #0099ff);
        }

        /* Main Container */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Controls */
        .controls {
            background: rgba(26, 26, 46, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.9rem;
            color: #888;
            font-weight: 500;
        }

        input[type="range"] {
            width: 200px;
            height: 6px;
            background: #333;
            outline: none;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #00d4ff;
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px #00d4ff;
        }

        input[type="text"], select {
            background: #1a1a2e;
            border: 1px solid #333;
            color: #fff;
            padding: 0.6rem 1rem;
            border-radius: 6px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .btn {
            background: linear-gradient(135deg, #00d4ff, #0099ff);
            color: white;
            border: none;
            padding: 0.7rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        /* Visualization Containers */
        .viz-container {
            background: rgba(26, 26, 46, 0.3);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            position: relative;
            min-height: 600px;
        }

        .viz-header {
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .viz-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #fff;
        }

        /* Loading Spinner */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(0, 212, 255, 0.2);
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Tooltips */
        .tooltip {
            position: absolute;
            padding: 12px;
            background: rgba(20, 20, 40, 0.95);
            border: 1px solid #00d4ff;
            border-radius: 8px;
            pointer-events: none;
            font-size: 0.9rem;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 20px rgba(0, 212, 255, 0.3);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            color: #00d4ff;
            margin-bottom: 8px;
        }

        .tooltip-value {
            color: #fff;
            font-size: 1.1rem;
            font-weight: 700;
        }

        /* Network Visualization */
        #network-viz {
            width: 100%;
            height: 700px;
            position: relative;
            cursor: grab;
        }

        #network-viz.grabbing {
            cursor: grabbing;
        }

        /* Matrix Visualization */
        #matrix-viz {
            width: 100%;
            height: 700px;
            overflow: auto;
            position: relative;
        }

        /* PCA Visualization */
        #pca-viz {
            width: 100%;
            height: 600px;
        }

        /* Info Panel */
        .info-panel {
            background: rgba(26, 26, 46, 0.8);
            border-radius: 8px;
            padding: 1.5rem;
            margin-top: 1rem;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .info-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 0.3rem;
        }

        .info-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: #00d4ff;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        /* Performance Monitor */
        .perf-monitor {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(26, 26, 46, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            font-family: monospace;
            min-width: 200px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
            }

            .stats {
                gap: 1rem;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .control-group {
                width: 100%;
            }

            input[type="range"] {
                width: 100%;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .viz-container {
            animation: fadeIn 0.6s ease;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }

        ::-webkit-scrollbar-thumb {
            background: #00d4ff;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #0099ff;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <div class="header">
        <div class="header-content">
            <h1>Stock Correlation Analysis Dashboard</h1>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="total-symbols">0</div>
                    <div class="stat-label">Symbols</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="total-correlations">0</div>
                    <div class="stat-label">Correlations</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="data-points">0</div>
                    <div class="stat-label">Data Points</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <div class="nav-tabs">
        <div class="nav-tabs-content">
            <button class="tab active" data-tab="network">Network Graph</button>
            <button class="tab" data-tab="matrix">Correlation Matrix</button>
            <button class="tab" data-tab="pca">PCA Analysis</button>
            <button class="tab" data-tab="regime">Market Regime</button>
            <button class="tab" data-tab="pairs">Pairs Trading</button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container">
        <!-- Network View -->
        <div id="network-view" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>Correlation Threshold</label>
                    <input type="range" id="threshold-slider" min="0" max="1" step="0.01" value="0.5">
                    <span id="threshold-value">0.50</span>
                </div>
                <div class="control-group">
                    <label>Node Size</label>
                    <select id="node-size-metric">
                        <option value="degree">Degree</option>
                        <option value="strength">Strength</option>
                        <option value="betweenness">Betweenness</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Search Symbol</label>
                    <input type="text" id="symbol-search" placeholder="Enter symbol...">
                </div>
                <button class="btn" id="reset-network">Reset View</button>
                <button class="btn" id="export-network">Export PNG</button>
            </div>

            <div class="viz-container">
                <div class="viz-header">
                    <h2 class="viz-title">Correlation Network</h2>
                    <div id="network-stats"></div>
                </div>
                <div id="network-viz"></div>
                <div class="loading" id="network-loading">
                    <div class="spinner"></div>
                </div>
            </div>

            <div class="info-panel">
                <h3>Network Insights</h3>
                <div class="info-grid" id="network-insights">
                    <!-- Dynamically populated -->
                </div>
            </div>
        </div>

        <!-- Matrix View -->
        <div id="matrix-view" class="tab-content" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <label>Sort By</label>
                    <select id="matrix-sort">
                        <option value="original">Original Order</option>
                        <option value="cluster">Cluster</option>
                        <option value="correlation">Average Correlation</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Color Scale</label>
                    <select id="color-scale">
                        <option value="diverging">Diverging</option>
                        <option value="sequential">Sequential</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Show Values</label>
                    <input type="checkbox" id="show-values">
                </div>
            </div>

            <div class="viz-container">
                <div class="viz-header">
                    <h2 class="viz-title">Correlation Matrix</h2>
                </div>
                <div id="matrix-viz"></div>
                <div class="loading" id="matrix-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>

        <!-- PCA View -->
        <div id="pca-view" class="tab-content" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <label>PC X-Axis</label>
                    <select id="pca-x-axis">
                        <option value="0">PC1</option>
                        <option value="1">PC2</option>
                        <option value="2">PC3</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>PC Y-Axis</label>
                    <select id="pca-y-axis">
                        <option value="1">PC2</option>
                        <option value="0">PC1</option>
                        <option value="2">PC3</option>
                    </select>
                </div>
            </div>

            <div class="viz-container">
                <div class="viz-header">
                    <h2 class="viz-title">Principal Component Analysis</h2>
                </div>
                <div id="pca-viz"></div>
                <div class="loading" id="pca-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>

        <!-- Regime View -->
        <div id="regime-view" class="tab-content" style="display: none;">
            <div class="viz-container">
                <div class="viz-header">
                    <h2 class="viz-title">Market Correlation Regime</h2>
                </div>
                <div id="regime-viz"></div>
                <div class="loading" id="regime-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>

        <!-- Pairs View -->
        <div id="pairs-view" class="tab-content" style="display: none;">
            <div class="controls">
                <div class="control-group">
                    <label>Min Correlation</label>
                    <input type="range" id="pairs-threshold" min="0.7" max="1" step="0.01" value="0.8">
                    <span id="pairs-threshold-value">0.80</span>
                </div>
            </div>

            <div class="viz-container">
                <div class="viz-header">
                    <h2 class="viz-title">High Correlation Pairs</h2>
                </div>
                <div id="pairs-viz"></div>
                <div class="loading" id="pairs-loading">
                    <div class="spinner"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip" id="tooltip"></div>

    <!-- Performance Monitor -->
    <div class="perf-monitor" id="perf-monitor">
        <div>FPS: <span id="fps">0</span></div>
        <div>Render Time: <span id="render-time">0</span>ms</div>
        <div>Memory: <span id="memory">0</span>MB</div>
    </div>

    <script>
        // Global state
        let correlationData = null;
        let networkData = null;
        let pcaData = null;
        let regimeData = null;
        let currentView = 'network';
        let networkSimulation = null;
        let performanceStats = {
            fps: 0,
            frameCount: 0,
            lastTime: performance.now()
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            setupEventListeners();
            loadData();
            startPerformanceMonitor();
        });

        // Event Listeners
        function setupEventListeners() {
            // Tab switching
            document.querySelectorAll('.tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    switchTab(e.target.dataset.tab);
                });
            });

            // Network controls
            document.getElementById('threshold-slider').addEventListener('input', (e) => {
                document.getElementById('threshold-value').textContent = parseFloat(e.target.value).toFixed(2);
                if (currentView === 'network') {
                    updateNetworkThreshold(parseFloat(e.target.value));
                }
            });

            document.getElementById('reset-network').addEventListener('click', resetNetworkView);
            document.getElementById('export-network').addEventListener('click', exportNetwork);

            document.getElementById('symbol-search').addEventListener('input', (e) => {
                searchSymbol(e.target.value);
            });

            // Matrix controls
            document.getElementById('matrix-sort').addEventListener('change', updateMatrixSort);
            document.getElementById('color-scale').addEventListener('change', updateColorScale);

            // PCA controls
            document.getElementById('pca-x-axis').addEventListener('change', updatePCAAxes);
            document.getElementById('pca-y-axis').addEventListener('change', updatePCAAxes);

            // Pairs controls
            document.getElementById('pairs-threshold').addEventListener('input', (e) => {
                document.getElementById('pairs-threshold-value').textContent = parseFloat(e.target.value).toFixed(2);
                updatePairsThreshold(parseFloat(e.target.value));
            });
        }

        // Tab switching
        function switchTab(tabName) {
            // Update active tab
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === tabName);
            });

            // Hide all content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.display = 'none';
            });

            // Show selected content
            document.getElementById(`${tabName}-view`).style.display = 'block';
            currentView = tabName;

            // Render visualization
            switch(tabName) {
                case 'network':
                    renderNetwork();
                    break;
                case 'matrix':
                    renderMatrix();
                    break;
                case 'pca':
                    renderPCA();
                    break;
                case 'regime':
                    renderRegime();
                    break;
                case 'pairs':
                    renderPairs();
                    break;
            }
        }

        // Data loading (simulate loading from JSON files)
        async function loadData() {
            try {
                // In a real app, these would be fetched from your server
                // For demo, we'll generate sample data
                correlationData = generateSampleCorrelationData(100);
                networkData = generateNetworkFromCorrelation(correlationData);
                pcaData = generateSamplePCAData();
                regimeData = generateSampleRegimeData();

                updateStats();
                renderNetwork();
            } catch (error) {
                console.error('Error loading data:', error);
            }
        }

        // Update statistics
        function updateStats() {
            if (correlationData) {
                document.getElementById('total-symbols').textContent = correlationData.symbols.length;
                document.getElementById('total-correlations').textContent = correlationData.significant_correlations.length;
                document.getElementById('data-points').textContent = correlationData.metadata.total_data_points || 'N/A';
            }
        }

        // Network Visualization
        function renderNetwork() {
            const container = d3.select('#network-viz');
            container.selectAll('*').remove();

            if (!networkData || !networkData.nodes.length) {
                container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '2rem')
                    .text('No network data available');
                return;
            }

            const width = container.node().offsetWidth;
            const height = container.node().offsetHeight;

            const svg = container.append('svg')
                .attr('width', width)
                .attr('height', height);

            // Create zoom behavior
            const zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });

            svg.call(zoom);

            const g = svg.append('g');

            // Create force simulation
            networkSimulation = d3.forceSimulation(networkData.nodes)
                .force('link', d3.forceLink(networkData.edges)
                    .id(d => d.id)
                    .strength(d => Math.abs(d.weight)))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));

            // Create links
            const link = g.append('g')
                .selectAll('line')
                .data(networkData.edges)
                .enter().append('line')
                .attr('stroke', d => d.weight > 0 ? '#00d4ff' : '#ff4444')
                .attr('stroke-opacity', d => Math.abs(d.weight) * 0.6)
                .attr('stroke-width', d => Math.abs(d.weight) * 3);

            // Create nodes
            const node = g.append('g')
                .selectAll('circle')
                .data(networkData.nodes)
                .enter().append('circle')
                .attr('r', d => 5 + (d.degree || 1) * 2)
                .attr('fill', '#00d4ff')
                .attr('stroke', '#fff')
                .attr('stroke-width', 2)
                .call(drag(networkSimulation));

            // Create labels
            const label = g.append('g')
                .selectAll('text')
                .data(networkData.nodes)
                .enter().append('text')
                .text(d => d.id)
                .attr('font-size', '10px')
                .attr('fill', '#fff')
                .attr('text-anchor', 'middle')
                .attr('dy', -15);

            // Add hover effects
            node.on('mouseover', function(event, d) {
                showTooltip(event, `${d.id}<br>Connections: ${d.degree || 0}`);
                d3.select(this).attr('r', 20);
            })
            .on('mouseout', function(event, d) {
                hideTooltip();
                d3.select(this).attr('r', 5 + (d.degree || 1) * 2);
            });

            // Update positions on tick
            networkSimulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y);

                label
                    .attr('x', d => d.x)
                    .attr('y', d => d.y);
            });

            // Update network insights
            updateNetworkInsights();
        }

        // Drag behavior for network nodes
        function drag(simulation) {
            function dragstarted(event) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                event.subject.fx = event.subject.x;
                event.subject.fy = event.subject.y;
            }

            function dragged(event) {
                event.subject.fx = event.x;
                event.subject.fy = event.y;
            }

            function dragended(event) {
                if (!event.active) simulation.alphaTarget(0);
                event.subject.fx = null;
                event.subject.fy = null;
            }

            return d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended);
        }

        // Update network based on threshold
        function updateNetworkThreshold(threshold) {
            if (!correlationData) return;

            // Filter edges based on threshold
            const filteredEdges = correlationData.significant_correlations
                .filter(c => Math.abs(c.correlation) >= threshold)
                .map(c => ({
                    source: c.symbol1,
                    target: c.symbol2,
                    weight: c.correlation
                }));

            // Get connected nodes
            const connectedNodes = new Set();
            filteredEdges.forEach(edge => {
                connectedNodes.add(edge.source);
                connectedNodes.add(edge.target);
            });

            // Update network data
            networkData = {
                nodes: Array.from(connectedNodes).map(id => ({ id, degree: 0 })),
                edges: filteredEdges
            };

            // Calculate degree
            networkData.edges.forEach(edge => {
                const sourceNode = networkData.nodes.find(n => n.id === edge.source);
                const targetNode = networkData.nodes.find(n => n.id === edge.target);
                if (sourceNode) sourceNode.degree++;
                if (targetNode) targetNode.degree++;
            });

            renderNetwork();
        }

        // Search symbol in network
        function searchSymbol(query) {
            if (!query) {
                d3.selectAll('circle').attr('opacity', 1);
                d3.selectAll('text').attr('opacity', 1);
                return;
            }

            const upperQuery = query.toUpperCase();
            d3.selectAll('circle').attr('opacity', d => 
                d.id.toUpperCase().includes(upperQuery) ? 1 : 0.2
            );
            d3.selectAll('text').attr('opacity', d => 
                d.id.toUpperCase().includes(upperQuery) ? 1 : 0.2
            );
        }

        // Update network insights
        function updateNetworkInsights() {
            if (!networkData) return;

            const insights = document.getElementById('network-insights');
            insights.innerHTML = '';

            // Calculate network metrics
            const metrics = calculateNetworkMetrics();

            // Display metrics
            Object.entries(metrics).forEach(([key, value]) => {
                const item = document.createElement('div');
                item.className = 'info-item';
                item.innerHTML = `
                    <div class="info-label">${key}</div>
                    <div class="info-value">${value}</div>
                `;
                insights.appendChild(item);
            });
        }

        // Calculate network metrics
        function calculateNetworkMetrics() {
            if (!networkData) return {};

            const avgDegree = networkData.nodes.reduce((sum, n) => sum + (n.degree || 0), 0) / networkData.nodes.length;
            const density = (2 * networkData.edges.length) / (networkData.nodes.length * (networkData.nodes.length - 1));
            
            return {
                'Nodes': networkData.nodes.length,
                'Edges': networkData.edges.length,
                'Avg Degree': avgDegree.toFixed(2),
                'Density': (density * 100).toFixed(1) + '%',
                'Clusters': detectClusters(networkData).length
            };
        }

        // Simple cluster detection
        function detectClusters(network) {
            // Simplified community detection
            const visited = new Set();
            const clusters = [];

            network.nodes.forEach(node => {
                if (!visited.has(node.id)) {
                    const cluster = new Set();
                    const queue = [node.id];

                    while (queue.length > 0) {
                        const current = queue.shift();
                        if (!visited.has(current)) {
                            visited.add(current);
                            cluster.add(current);

                            // Find neighbors
                            network.edges.forEach(edge => {
                                if (edge.source === current || edge.source.id === current) {
                                    const target = edge.target.id || edge.target;
                                    if (!visited.has(target)) queue.push(target);
                                }
                                if (edge.target === current || edge.target.id === current) {
                                    const source = edge.source.id || edge.source;
                                    if (!visited.has(source)) queue.push(source);
                                }
                            });
                        }
                    }

                    if (cluster.size > 1) clusters.push(cluster);
                }
            });

            return clusters;
        }

        // Matrix Visualization
        function renderMatrix() {
            const container = d3.select('#matrix-viz');
            container.selectAll('*').remove();

            if (!correlationData || !correlationData.symbols.length) {
                container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '2rem')
                    .text('No correlation data available');
                return;
            }

            // For large matrices, use canvas for better performance
            if (correlationData.symbols.length > 50) {
                renderMatrixCanvas();
                return;
            }

            const margin = {top: 100, right: 100, bottom: 10, left: 100};
            const width = container.node().offsetWidth - margin.left - margin.right;
            const height = width; // Square matrix

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Create scales
            const x = d3.scaleBand()
                .domain(correlationData.symbols)
                .range([0, width])
                .padding(0.01);

            const y = d3.scaleBand()
                .domain(correlationData.symbols)
                .range([0, height])
                .padding(0.01);

            const colorScale = d3.scaleLinear()
                .domain([-1, 0, 1])
                .range(['#ff4444', '#333', '#00d4ff']);

            // Create matrix from sparse data
            const matrix = createFullMatrix();

            // Draw cells
            g.selectAll('.cell')
                .data(matrix)
                .enter().append('rect')
                .attr('class', 'cell')
                .attr('x', d => x(d.symbol1))
                .attr('y', d => y(d.symbol2))
                .attr('width', x.bandwidth())
                .attr('height', y.bandwidth())
                .attr('fill', d => colorScale(d.value))
                .on('mouseover', (event, d) => {
                    showTooltip(event, `${d.symbol1} - ${d.symbol2}<br>Correlation: ${d.value.toFixed(3)}`);
                })
                .on('mouseout', hideTooltip);

            // Add labels
            g.selectAll('.x-label')
                .data(correlationData.symbols)
                .enter().append('text')
                .attr('class', 'x-label')
                .attr('x', d => x(d) + x.bandwidth() / 2)
                .attr('y', -5)
                .attr('text-anchor', 'start')
                .attr('transform', d => `rotate(-45, ${x(d) + x.bandwidth() / 2}, -5)`)
                .text(d => d)
                .style('font-size', '10px')
                .style('fill', '#fff');

            g.selectAll('.y-label')
                .data(correlationData.symbols)
                .enter().append('text')
                .attr('class', 'y-label')
                .attr('x', -5)
                .attr('y', d => y(d) + y.bandwidth() / 2)
                .attr('text-anchor', 'end')
                .attr('alignment-baseline', 'middle')
                .text(d => d)
                .style('font-size', '10px')
                .style('fill', '#fff');
        }

        // Canvas-based matrix for large datasets
        function renderMatrixCanvas() {
            const container = document.getElementById('matrix-viz');
            container.innerHTML = '';

            const canvas = document.createElement('canvas');
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            canvas.width = width;
            canvas.height = height;
            container.appendChild(canvas);

            const ctx = canvas.getContext('2d');
            const n = correlationData.symbols.length;
            const cellSize = Math.min((width - 100) / n, (height - 100) / n);

            // Create color scale
            const getColor = (value) => {
                const r = value > 0 ? 0 : 255;
                const g = Math.abs(value) * 100;
                const b = value < 0 ? 68 : 255;
                const a = Math.abs(value);
                return `rgba(${r}, ${g}, ${b}, ${a})`;
            };

            // Draw matrix
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, width, height);

            // Create full matrix from sparse data
            const matrix = {};
            correlationData.significant_correlations.forEach(c => {
                const key1 = `${c.i}-${c.j}`;
                const key2 = `${c.j}-${c.i}`;
                matrix[key1] = c.correlation;
                matrix[key2] = c.correlation;
            });

            // Draw cells
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    const x = 50 + i * cellSize;
                    const y = 50 + j * cellSize;
                    const value = i === j ? 1 : (matrix[`${i}-${j}`] || 0);
                    
                    ctx.fillStyle = getColor(value);
                    ctx.fillRect(x, y, cellSize - 1, cellSize - 1);
                }
            }

            // Add hover interaction
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left - 50;
                const y = e.clientY - rect.top - 50;
                
                const i = Math.floor(x / cellSize);
                const j = Math.floor(y / cellSize);
                
                if (i >= 0 && i < n && j >= 0 && j < n) {
                    const value = i === j ? 1 : (matrix[`${i}-${j}`] || 0);
                    showTooltip(e, `${correlationData.symbols[i]} - ${correlationData.symbols[j]}<br>Correlation: ${value.toFixed(3)}`);
                } else {
                    hideTooltip();
                }
            });

            canvas.addEventListener('mouseleave', hideTooltip);
        }

        // Create full matrix from sparse data
        function createFullMatrix() {
            const matrix = [];
            const symbolMap = {};
            correlationData.symbols.forEach((s, i) => symbolMap[s] = i);

            // Initialize with zeros and diagonal ones
            for (let i = 0; i < correlationData.symbols.length; i++) {
                for (let j = 0; j < correlationData.symbols.length; j++) {
                    matrix.push({
                        symbol1: correlationData.symbols[i],
                        symbol2: correlationData.symbols[j],
                        value: i === j ? 1 : 0
                    });
                }
            }

            // Fill in correlations
            correlationData.significant_correlations.forEach(c => {
                const idx1 = symbolMap[c.symbol1] * correlationData.symbols.length + symbolMap[c.symbol2];
                const idx2 = symbolMap[c.symbol2] * correlationData.symbols.length + symbolMap[c.symbol1];
                
                if (matrix[idx1]) matrix[idx1].value = c.correlation;
                if (matrix[idx2]) matrix[idx2].value = c.correlation;
            });

            return matrix;
        }

        // PCA Visualization
        function renderPCA() {
            const container = d3.select('#pca-viz');
            container.selectAll('*').remove();

            if (!pcaData) {
                container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '2rem')
                    .text('No PCA data available');
                return;
            }

            const margin = {top: 40, right: 40, bottom: 60, left: 60};
            const width = container.node().offsetWidth - margin.left - margin.right;
            const height = container.node().offsetHeight - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Get selected axes
            const xAxis = parseInt(document.getElementById('pca-x-axis').value);
            const yAxis = parseInt(document.getElementById('pca-y-axis').value);

            // Create scales
            const xScale = d3.scaleLinear()
                .domain(d3.extent(pcaData.loadings[`PC${xAxis + 1}`]))
                .range([0, width])
                .nice();

            const yScale = d3.scaleLinear()
                .domain(d3.extent(pcaData.loadings[`PC${yAxis + 1}`]))
                .range([height, 0])
                .nice();

            // Add axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale))
                .append('text')
                .attr('x', width / 2)
                .attr('y', 40)
                .attr('fill', '#fff')
                .style('text-anchor', 'middle')
                .text(`PC${xAxis + 1} (${(pcaData.explained_variance[xAxis] * 100).toFixed(1)}%)`);

            g.append('g')
                .call(d3.axisLeft(yScale))
                .append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -40)
                .attr('x', -height / 2)
                .attr('fill', '#fff')
                .style('text-anchor', 'middle')
                .text(`PC${yAxis + 1} (${(pcaData.explained_variance[yAxis] * 100).toFixed(1)}%)`);

            // Add gridlines
            g.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''))
                .style('stroke-dasharray', '3,3')
                .style('opacity', 0.3);

            g.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''))
                .style('stroke-dasharray', '3,3')
                .style('opacity', 0.3);

            // Plot points
            const points = pcaData.symbols.map((symbol, i) => ({
                symbol: symbol,
                x: pcaData.loadings[`PC${xAxis + 1}`][i],
                y: pcaData.loadings[`PC${yAxis + 1}`][i]
            }));

            g.selectAll('.point')
                .data(points)
                .enter().append('circle')
                .attr('class', 'point')
                .attr('cx', d => xScale(d.x))
                .attr('cy', d => yScale(d.y))
                .attr('r', 5)
                .attr('fill', '#00d4ff')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1)
                .on('mouseover', function(event, d) {
                    showTooltip(event, `${d.symbol}<br>PC${xAxis + 1}: ${d.x.toFixed(3)}<br>PC${yAxis + 1}: ${d.y.toFixed(3)}`);
                    d3.select(this).attr('r', 8);
                })
                .on('mouseout', function() {
                    hideTooltip();
                    d3.select(this).attr('r', 5);
                });

            // Variance explained chart
            renderVarianceChart();
        }

        // Variance explained chart
        function renderVarianceChart() {
            const container = d3.select('#pca-viz');
            
            const varChartWidth = 300;
            const varChartHeight = 150;
            const margin = {top: 20, right: 20, bottom: 40, left: 50};

            const varSvg = container.append('svg')
                .attr('width', varChartWidth)
                .attr('height', varChartHeight)
                .style('position', 'absolute')
                .style('top', '20px')
                .style('right', '20px')
                .style('background', 'rgba(26, 26, 46, 0.9)')
                .style('border-radius', '8px')
                .style('padding', '10px');

            const g = varSvg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            const width = varChartWidth - margin.left - margin.right;
            const height = varChartHeight - margin.top - margin.bottom;

            // Prepare data
            const varData = pcaData.explained_variance.map((v, i) => ({
                component: `PC${i + 1}`,
                variance: v * 100,
                cumulative: pcaData.cumulative_variance[i] * 100
            }));

            // Scales
            const x = d3.scaleBand()
                .domain(varData.map(d => d.component))
                .range([0, width])
                .padding(0.1);

            const y = d3.scaleLinear()
                .domain([0, 100])
                .range([height, 0]);

            // Bars
            g.selectAll('.var-bar')
                .data(varData)
                .enter().append('rect')
                .attr('class', 'var-bar')
                .attr('x', d => x(d.component))
                .attr('y', d => y(d.variance))
                .attr('width', x.bandwidth())
                .attr('height', d => height - y(d.variance))
                .attr('fill', '#00d4ff')
                .attr('opacity', 0.7);

            // Cumulative line
            const line = d3.line()
                .x(d => x(d.component) + x.bandwidth() / 2)
                .y(d => y(d.cumulative));

            g.append('path')
                .datum(varData)
                .attr('fill', 'none')
                .attr('stroke', '#ff6b6b')
                .attr('stroke-width', 2)
                .attr('d', line);

            // Labels
            g.append('text')
                .attr('x', width / 2)
                .attr('y', -5)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .style('fill', '#fff')
                .text('Variance Explained');

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .style('font-size', '10px');

            g.append('g')
                .call(d3.axisLeft(y).ticks(5))
                .style('font-size', '10px');
        }

        // Market Regime Visualization
        function renderRegime() {
            const container = d3.select('#regime-viz');
            container.selectAll('*').remove();

            if (!regimeData) {
                container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '2rem')
                    .text('No regime data available');
                return;
            }

            const margin = {top: 40, right: 40, bottom: 60, left: 60};
            const width = container.node().offsetWidth - margin.left - margin.right;
            const height = container.node().offsetHeight - margin.top - margin.bottom;

            const svg = container.append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Parse dates
            const data = regimeData.dates.map((d, i) => ({
                date: new Date(d),
                correlation: regimeData.correlations[i]
            }));

            // Scales
            const xScale = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([0, width]);

            const yScale = d3.scaleLinear()
                .domain([0, 1])
                .range([height, 0]);

            // Area generator
            const area = d3.area()
                .x(d => xScale(d.date))
                .y0(height)
                .y1(d => yScale(d.correlation))
                .curve(d3.curveMonotoneX);

            // Add gradient
            const gradient = svg.append('defs')
                .append('linearGradient')
                .attr('id', 'regime-gradient')
                .attr('gradientUnits', 'userSpaceOnUse')
                .attr('x1', 0).attr('y1', yScale(0))
                .attr('x2', 0).attr('y2', yScale(1));

            gradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', '#00d4ff')
                .attr('stop-opacity', 0.1);

            gradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', '#00d4ff')
                .attr('stop-opacity', 0.8);

            // Draw area
            g.append('path')
                .datum(data)
                .attr('fill', 'url(#regime-gradient)')
                .attr('d', area);

            // Draw line
            const line = d3.line()
                .x(d => xScale(d.date))
                .y(d => yScale(d.correlation))
                .curve(d3.curveMonotoneX);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#00d4ff')
                .attr('stroke-width', 2)
                .attr('d', line);

            // Add mean line
            g.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', yScale(regimeData.statistics.mean))
                .attr('y2', yScale(regimeData.statistics.mean))
                .attr('stroke', '#ff6b6b')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,5');

            // Add confidence bands
            g.append('rect')
                .attr('x', 0)
                .attr('y', yScale(regimeData.statistics.upper_bound))
                .attr('width', width)
                .attr('height', yScale(regimeData.statistics.lower_bound) - yScale(regimeData.statistics.upper_bound))
                .attr('fill', '#ff6b6b')
                .attr('opacity', 0.1);

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale).tickFormat(d3.timeFormat('%Y-%m')));

            g.append('g')
                .call(d3.axisLeft(yScale));

            // Labels
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -40)
                .attr('x', -height / 2)
                .style('text-anchor', 'middle')
                .style('fill', '#fff')
                .text('Average Correlation');

            g.append('text')
                .attr('x', width / 2)
                .attr('y', height + 50)
                .style('text-anchor', 'middle')
                .style('fill', '#fff')
                .text('Date');

            // Interactive overlay
            const bisect = d3.bisector(d => d.date).left;
            
            const focus = g.append('g')
                .style('display', 'none');

            focus.append('circle')
                .attr('r', 5)
                .attr('fill', '#00d4ff');

            focus.append('line')
                .attr('class', 'x-hover-line')
                .attr('stroke', '#fff')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '3,3');

            svg.append('rect')
                .attr('transform', `translate(${margin.left},${margin.top})`)
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('mouseover', () => focus.style('display', null))
                .on('mouseout', () => {
                    focus.style('display', 'none');
                    hideTooltip();
                })
                .on('mousemove', function(event) {
                    const x0 = xScale.invert(d3.pointer(event)[0]);
                    const i = bisect(data, x0, 1);
                    const d0 = data[i - 1];
                    const d1 = data[i];
                    const d = x0 - d0.date > d1.date - x0 ? d1 : d0;
                    
                    focus.attr('transform', `translate(${xScale(d.date)},${yScale(d.correlation)})`);
                    focus.select('.x-hover-line')
                        .attr('y1', 0)
                        .attr('y2', height - yScale(d.correlation));
                    
                    showTooltip(event, `Date: ${d3.timeFormat('%Y-%m-%d')(d.date)}<br>Correlation: ${d.correlation.toFixed(3)}`);
                });
        }

        // Pairs Trading Visualization
        function renderPairs() {
            const container = d3.select('#pairs-viz');
            container.selectAll('*').remove();

            const threshold = parseFloat(document.getElementById('pairs-threshold').value);
            
            // Filter pairs based on threshold
            const filteredPairs = correlationData.significant_correlations
                .filter(c => c.correlation >= threshold)
                .sort((a, b) => b.correlation - a.correlation);

            if (filteredPairs.length === 0) {
                container.append('div')
                    .style('text-align', 'center')
                    .style('padding', '2rem')
                    .text('No pairs found above threshold');
                return;
            }

            // Create table
            const table = container.append('table')
                .style('width', '100%')
                .style('border-collapse', 'collapse');

            // Header
            const thead = table.append('thead');
            thead.append('tr')
                .selectAll('th')
                .data(['Rank', 'Symbol 1', 'Symbol 2', 'Correlation', 'Action'])
                .enter().append('th')
                .text(d => d)
                .style('padding', '12px')
                .style('text-align', 'left')
                .style('border-bottom', '2px solid #00d4ff')
                .style('color', '#00d4ff');

            // Body
            const tbody = table.append('tbody');
            const rows = tbody.selectAll('tr')
                .data(filteredPairs.slice(0, 50)) // Show top 50
                .enter().append('tr')
                .style('border-bottom', '1px solid #333')
                .on('mouseover', function() {
                    d3.select(this).style('background', 'rgba(0, 212, 255, 0.1)');
                })
                .on('mouseout', function() {
                    d3.select(this).style('background', 'transparent');
                });

            rows.selectAll('td')
                .data((d, i) => [
                    i + 1,
                    d.symbol1,
                    d.symbol2,
                    d.correlation.toFixed(4),
                    'View Details'
                ])
                .enter().append('td')
                .text(d => d)
                .style('padding', '12px')
                .style('color', (d, i) => i === 4 ? '#00d4ff' : '#fff')
                .style('cursor', (d, i) => i === 4 ? 'pointer' : 'default')
                .on('click', function(event, d, i) {
                    if (d === 'View Details') {
                        const pairData = d3.select(this.parentNode).datum();
                        showPairDetails(pairData);
                    }
                });

            // Summary stats
            const avgCorr = d3.mean(filteredPairs, d => d.correlation);
            const summary = container.append('div')
                .attr('class', 'info-panel')
                .style('margin-top', '2rem');

            summary.append('h3').text('Summary Statistics');
            
            const summaryGrid = summary.append('div')
                .attr('class', 'info-grid');

            [
                { label: 'Total Pairs', value: filteredPairs.length },
                { label: 'Average Correlation', value: avgCorr.toFixed(3) },
                { label: 'Highest Correlation', value: filteredPairs[0].correlation.toFixed(4) },
                { label: 'Threshold', value: threshold.toFixed(2) }
            ].forEach(stat => {
                const item = summaryGrid.append('div')
                    .attr('class', 'info-item');
                item.append('div')
                    .attr('class', 'info-label')
                    .text(stat.label);
                item.append('div')
                    .attr('class', 'info-value')
                    .text(stat.value);
            });
        }

        // Update functions
        function updateMatrixSort() {
            // Implement matrix sorting logic
            renderMatrix();
        }

        function updateColorScale() {
            // Implement color scale change
            renderMatrix();
        }

        function updatePCAAxes() {
            renderPCA();
        }

        function updatePairsThreshold(threshold) {
            renderPairs();
        }

        function resetNetworkView() {
            if (networkSimulation) {
                networkSimulation.alpha(1).restart();
            }
        }

        function exportNetwork() {
            // Implement PNG export
            const svg = document.querySelector('#network-viz svg');
            if (!svg) return;

            // Convert SVG to PNG logic here
            alert('Export functionality would be implemented here');
        }

        function showPairDetails(pairData) {
            alert(`Details for ${pairData.symbol1} - ${pairData.symbol2}\nCorrelation: ${pairData.correlation}`);
        }

        // Tooltip functions
        function showTooltip(event, content) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = content;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY - 30 + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        // Performance monitoring
        function startPerformanceMonitor() {
            function updateStats() {
                // FPS calculation
                performanceStats.frameCount++;
                const currentTime = performance.now();
                const elapsed = currentTime - performanceStats.lastTime;
                
                if (elapsed >= 1000) {
                    performanceStats.fps = Math.round((performanceStats.frameCount * 1000) / elapsed);
                    performanceStats.frameCount = 0;
                    performanceStats.lastTime = currentTime;
                    
                    document.getElementById('fps').textContent = performanceStats.fps;
                }
                
                // Memory usage (if available)
                if (performance.memory) {
                    const memoryMB = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
                    document.getElementById('memory').textContent = memoryMB;
                }
                
                requestAnimationFrame(updateStats);
            }
            
            updateStats();
        }

        // Sample data generators (replace with actual data loading)
        function generateSampleCorrelationData(n) {
            const symbols = Array.from({length: n}, (_, i) => `SYM${i.toString().padStart(3, '0')}`);
            const correlations = [];
            
            // Generate sparse correlations
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    // Only store significant correlations
                    const corr = (Math.random() - 0.5) * 2;
                    if (Math.abs(corr) > 0.3) {
                        correlations.push({
                            i: i,
                            j: j,
                            symbol1: symbols[i],
                            symbol2: symbols[j],
                            correlation: corr
                        });
                    }
                }
            }
            
            return {
                symbols: symbols,
                significant_correlations: correlations,
                metadata: {
                    total_symbols: n,
                    compression_ratio: (n * n) / correlations.length,
                    sparsity: 1 - correlations.length / (n * n),
                    format: 'sparse',
                    total_data_points: 252 * 2 // Assuming 2 years of daily data
                }
            };
        }

        function generateNetworkFromCorrelation(corrData) {
            if (!corrData) return { nodes: [], edges: [] };
            
            const threshold = parseFloat(document.getElementById('threshold-slider').value);
            const edges = corrData.significant_correlations
                .filter(c => Math.abs(c.correlation) >= threshold)
                .map(c => ({
                    source: c.symbol1,
                    target: c.symbol2,
                    weight: c.correlation
                }));
            
            // Get unique nodes
            const nodeSet = new Set();
            edges.forEach(edge => {
                nodeSet.add(edge.source);
                nodeSet.add(edge.target);
            });
            
            const nodes = Array.from(nodeSet).map(id => {
                const degree = edges.filter(e => e.source === id || e.target === id).length;
                return { id, degree };
            });
            
            return { nodes, edges };
        }

        function generateSamplePCAData() {
            const n = 100;
            const symbols = Array.from({length: n}, (_, i) => `SYM${i.toString().padStart(3, '0')}`);
            
            return {
                explained_variance: [0.35, 0.20, 0.15, 0.10, 0.08],
                cumulative_variance: [0.35, 0.55, 0.70, 0.80, 0.88],
                loadings: {
                    PC1: Array.from({length: n}, () => (Math.random() - 0.5) * 2),
                    PC2: Array.from({length: n}, () => (Math.random() - 0.5) * 2),
                    PC3: Array.from({length: n}, () => (Math.random() - 0.5) * 2),
                    PC4: Array.from({length: n}, () => (Math.random() - 0.5) * 2),
                    PC5: Array.from({length: n}, () => (Math.random() - 0.5) * 2)
                },
                symbols: symbols
            };
        }

        function generateSampleRegimeData() {
            const days = 500;
            const dates = [];
            const correlations = [];
            
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - days);
            
            let correlation = 0.5;
            for (let i = 0; i < days; i++) {
                const date = new Date(startDate);
                date.setDate(date.getDate() + i);
                dates.push(date.toISOString().split('T')[0]);
                
                // Random walk with mean reversion
                correlation += (Math.random() - 0.5) * 0.05;
                correlation = Math.max(0.1, Math.min(0.9, correlation));
                correlations.push(correlation);
            }
            
            const mean = d3.mean(correlations);
            const std = d3.deviation(correlations);
            
            return {
                dates: dates,
                correlations: correlations,
                statistics: {
                    mean: mean,
                    std: std,
                    min: d3.min(correlations),
                    max: d3.max(correlations),
                    upper_bound: mean + std,
                    lower_bound: mean - std
                }
            };
        }

        // Data loading from files
        async function loadDataFromFiles() {
            try {
                // Show loading state
                document.querySelectorAll('.loading').forEach(el => el.classList.add('active'));
                
                // Load correlation matrix
                const corrResponse = await fetch('correlation_matrix.json');
                const corrJson = await corrResponse.json();
                
                // Convert to our format if needed
                if (corrJson.correlation_matrix) {
                    // Dense format - convert to sparse
                    correlationData = convertDenseToSparse(corrJson);
                } else {
                    // Already sparse
                    correlationData = corrJson;
                }
                
                // Load network data
                const netResponse = await fetch('correlation_network.json');
                networkData = await netResponse.json();
                
                // Load PCA data
                const pcaResponse = await fetch('pca_analysis.json');
                const pcaJson = await pcaResponse.json();
                pcaData = {
                    explained_variance: pcaJson.explained_variance_ratio,
                    cumulative_variance: pcaJson.cumulative_variance_ratio,
                    loadings: pcaJson.loadings.components,
                    symbols: pcaJson.loadings.symbols
                };
                
                // Load regime data
                const regimeResponse = await fetch('market_regime.json');
                regimeData = await regimeResponse.json();
                
                // Hide loading state
                document.querySelectorAll('.loading').forEach(el => el.classList.remove('active'));
                
                // Update UI
                updateStats();
                renderNetwork();
                
            } catch (error) {
                console.error('Error loading data:', error);
                // Fall back to sample data
                loadData();
            }
        }

        function convertDenseToSparse(denseData) {
            const correlations = [];
            const n = denseData.symbols.length;
            
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    const value = denseData.correlation_matrix[i][j];
                    if (Math.abs(value) > 0.1) { // Threshold for sparsity
                        correlations.push({
                            i: i,
                            j: j,
                            symbol1: denseData.symbols[i],
                            symbol2: denseData.symbols[j],
                            correlation: value
                        });
                    }
                }
            }
            
            return {
                symbols: denseData.symbols,
                significant_correlations: correlations,
                metadata: {
                    ...denseData.metadata,
                    compression_ratio: (n * n) / correlations.length,
                    sparsity: 1 - correlations.length / (n * n),
                    format: 'sparse'
                }
            };
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case '1':
                    switchTab('network');
                    break;
                case '2':
                    switchTab('matrix');
                    break;
                case '3':
                    switchTab('pca');
                    break;
                case '4':
                    switchTab('regime');
                    break;
                case '5':
                    switchTab('pairs');
                    break;
                case 'r':
                    if (currentView === 'network') resetNetworkView();
                    break;
                case 'Escape':
                    hideTooltip();
                    break;
            }
        });

        // Responsive handling
        window.addEventListener('resize', _.debounce(() => {
            switch(currentView) {
                case 'network':
                    renderNetwork();
                    break;
                case 'matrix':
                    renderMatrix();
                    break;
                case 'pca':
                    renderPCA();
                    break;
                case 'regime':
                    renderRegime();
                    break;
                case 'pairs':
                    renderPairs();
                    break;
            }
        }, 250));

        // WebGL renderer for ultra-large datasets (optional enhancement)
        class WebGLCorrelationRenderer {
            constructor(canvas, data) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2');
                this.data = data;
                this.initShaders();
                this.initBuffers();
            }
            
            initShaders() {
                // Vertex shader
                const vsSource = `
                    attribute vec2 a_position;
                    attribute float a_value;
                    uniform mat3 u_matrix;
                    varying float v_value;
                    
                    void main() {
                        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
                        v_value = a_value;
                        gl_PointSize = 4.0;
                    }
                `;
                
                // Fragment shader
                const fsSource = `
                    precision mediump float;
                    varying float v_value;
                    
                    void main() {
                        vec3 color = v_value > 0.0 ? 
                            vec3(0.0, 0.831, 1.0) : 
                            vec3(1.0, 0.267, 0.267);
                        gl_FragColor = vec4(color, abs(v_value));
                    }
                `;
                
                // Compile shaders (implementation details omitted for brevity)
            }
            
            initBuffers() {
                // Create buffers for positions and values
            }
            
            render() {
                // WebGL rendering logic
            }
        }

        // Export functionality
        function exportVisualization(type) {
            switch(type) {
                case 'png':
                    exportAsPNG();
                    break;
                case 'svg':
                    exportAsSVG();
                    break;
                case 'data':
                    exportData();
                    break;
            }
        }

        function exportAsPNG() {
            const svg = document.querySelector(`#${currentView}-viz svg`);
            if (!svg) return;
            
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const bbox = svg.getBoundingClientRect();
            
            canvas.width = bbox.width;
            canvas.height = bbox.height;
            
            // Convert SVG to canvas (requires additional library like canvg)
            // Implementation would go here
            
            // Download
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `correlation-${currentView}-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function exportData() {
            let dataToExport = {};
            
            switch(currentView) {
                case 'network':
                    dataToExport = networkData;
                    break;
                case 'matrix':
                    dataToExport = correlationData;
                    break;
                case 'pca':
                    dataToExport = pcaData;
                    break;
                case 'regime':
                    dataToExport = regimeData;
                    break;
                case 'pairs':
                    dataToExport = {
                        pairs: correlationData.significant_correlations
                            .filter(c => c.correlation >= parseFloat(document.getElementById('pairs-threshold').value))
                            .sort((a, b) => b.correlation - a.correlation)
                    };
                    break;
            }
            
            const blob = new Blob([JSON.stringify(dataToExport, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `correlation-${currentView}-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Initialize app
        console.log('Correlation Analysis Dashboard loaded successfully!');
    </script>
</body>
</html>